// /lib/repositories/orders.ts
import { q, sql } from "@/lib/db";

// ------------------------------------------------------------------
// INTERFACE EXISTENTE: OrderPayloadDB
// ------------------------------------------------------------------
// Data structure expected by the Repository/Table 'orders'
interface OrderPayloadDB {
    buyer_id: string;
    shipping_address: string;
    billing_address: string;
    status: 'pending' | 'completed' | 'shipped' | 'cancelled'; 
    subtotal_cents: number;
    shipping_cents: number;
    tax_cents: number;
    total_cents: number;
    currency: string;
}

// ------------------------------------------------------------------
// NOVA INTERFACE: OrderItemPayloadDB
// ------------------------------------------------------------------
/** Estrutura de dados esperada para cada item na tabela 'order_items' */
export interface OrderItemPayloadDB {
    order_id: string;
    product_id: string;
    seller_id: string; 
    title: string;
    quantity: number;
    price_cents: number;
    currency: string;
}

// ------------------------------------------------------------------
// FUNÇÃO EXISTENTE: createOrder
// ------------------------------------------------------------------
/**
 * Inserts a new order record into the 'orders' table.
 * @param payload The order data (already converted to cents and UUIDs).
 * @returns An object containing the ID generated by the DB.
 */
export async function createOrder(payload: OrderPayloadDB): Promise<{ id: string }> {
    const rows = await q<{ id: string }>`
        INSERT INTO orders (
            buyer_id, 
            shipping_address, 
            billing_address, 
            status, 
            subtotal_cents, 
            shipping_cents, 
            tax_cents, 
            total_cents, 
            currency
        )
        VALUES (
            ${payload.buyer_id}, 
            ${payload.shipping_address}, 
            ${payload.billing_address}, 
            ${payload.status}, 
            ${payload.subtotal_cents}, 
            ${payload.shipping_cents}, 
            ${payload.tax_cents}, 
            ${payload.total_cents}, 
            ${payload.currency}
        )
        RETURNING id::text AS id;
    `;

    if (!rows[0]) {
        throw new Error("Failed to create order: the database did not return the ID.");
    }

    return { id: rows[0].id };
}

// ------------------------------------------------------------------
// NOVA FUNÇÃO: createOrderItems (CORRIGIDA)
// ------------------------------------------------------------------
/**
 * Insere múltiplos itens de pedido na tabela 'order_items' usando inserção em lote.
 * Usa type casting para simular TemplateStringsArray e satisfazer 'q'.
 * @param itemsPayload Array de dados dos itens do pedido.
 */
export async function createOrderItems(itemsPayload: OrderItemPayloadDB[]): Promise<void> {
    if (itemsPayload.length === 0) {
        return; 
    }
    const COLUMNS_PER_ITEM = 7; 

    // 1. Gera a string VALUES com placeholders PostgreSQL ($1, $2, ...)
    const valuesPlaceholders = itemsPayload.map((_, itemIndex) => {
        const startIndex = itemIndex * COLUMNS_PER_ITEM;
        // Cria placeholders para um único item: ($1, $2, $3, $4, $5, $6, $7)
        const placeholders = Array.from({ length: COLUMNS_PER_ITEM }, (_, colIndex) => 
            `$${startIndex + colIndex + 1}`
        ).join(', ');
        return `(${placeholders})`;
    }).join(', ');
    
    // 2. Constrói a string final da query (string bruta)
    const rawQuery = `
        INSERT INTO order_items (
            order_id, product_id, seller_id, title, quantity, price_cents, currency
        )
        VALUES ${valuesPlaceholders};
    `;
    
    // 3. Cria um array plano de valores
    const flatValues = itemsPayload.flatMap(item => [
        item.order_id,
        item.product_id,
        item.seller_id,
        item.title,
        item.quantity,
        item.price_cents,
        item.currency
    ]);

    

    await sql.query(rawQuery, flatValues); 
}